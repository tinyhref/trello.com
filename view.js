/* view.tsx generated by @compiled/babel-plugin v0.38.1 */
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import "./view.compiled.css";
import { ax, ix } from "@compiled/react/runtime";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import * as React from 'react';
import { useCallback, useMemo, useState } from 'react';
import { Drawer, DrawerContent } from '@atlaskit/drawer';
import { combineExtensions, getInitialState } from './utils';
import { AnalyticsContext } from '@atlaskit/analytics-next';
import { toCrossFlowOrigin } from '../utils/toCrossFlowOrigin';
import { flushSync } from 'react-dom';
import { ViewStateContext } from './context';
import { CrossFlowSupportHeader } from './header';
import { Box } from '@atlaskit/primitives/compiled';
import { isFedRamp, isIsolatedCloud } from '@atlaskit/atlassian-context';
import IcFedrampScreen from './ic-fedramp-block-screen/icFedrampScreen';
import { fg } from '@atlaskit/platform-feature-flags';
var styles = {
  container: "_16jlkb7n _1o9zkb7n _i0dlf1ug _1e0c1txw _2lx21bp4",
  content: "_19pkze3t"
};
export var CompiledDrawerContainer = function CompiledDrawerContainer(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/React.createElement(Box, {
    testId: "cross-flow-support-content",
    xcss: styles.container
  }, children);
};
export var CompiledIntegrationView = function CompiledIntegrationView(_ref2) {
  var onAnalyticsEvent = _ref2.onAnalyticsEvent,
    onHandShake = _ref2.onHandShake,
    onClose = _ref2.onClose,
    ProductStoreComponent = _ref2.ProductStoreComponent,
    CrossFlowComponent = _ref2.CrossFlowComponent,
    cloudId = _ref2.cloudId,
    journey = _ref2.journey,
    targetProduct = _ref2.targetProduct,
    originProduct = _ref2.originProduct,
    sourceComponent = _ref2.sourceComponent,
    sourceContext = _ref2.sourceContext,
    locale = _ref2.locale,
    edgePrefix = _ref2.edgePrefix,
    theme = _ref2.theme,
    redirectToWac = _ref2.redirectToWac,
    zIndex = _ref2.zIndex,
    env = _ref2.env,
    experimentalOptions = _ref2.experimentalOptions,
    extensions = _ref2.extensions,
    plugins = _ref2.plugins;
  var _useState = useState(true),
    _useState2 = _slicedToArray(_useState, 2),
    isDrawerOpen = _useState2[0],
    setIsDrawerOpen = _useState2[1];
  var _useState3 = useState({}),
    _useState4 = _slicedToArray(_useState3, 2),
    completionStatus = _useState4[0],
    setCompletionStatus = _useState4[1];
  var _useState5 = useState(getInitialState({
      journey: journey,
      targetProduct: targetProduct,
      sourceComponent: sourceComponent,
      sourceContext: sourceContext
    })),
    _useState6 = _slicedToArray(_useState5, 2),
    viewState = _useState6[0],
    setViewState = _useState6[1];
  var analyticsContext = useMemo(function () {
    return {
      cloudId: cloudId,
      journey: journey,
      targetProduct: targetProduct,
      originProduct: originProduct,
      sourceComponent: sourceComponent,
      sourceContext: sourceContext
    };
  }, [cloudId, journey, targetProduct, originProduct, sourceComponent, sourceContext]);
  var closeDrawer = useCallback(function () {
    setIsDrawerOpen(false);
  }, []);

  /**
   * Cross-flow Drawer Close
   */
  var handleOnClose = useCallback(function (_, analyticEvent) {
    var _analyticsContext$tar;
    var context = analyticEvent.context,
      payload = analyticEvent.payload;
    onAnalyticsEvent({
      context: [context, _objectSpread(_objectSpread({}, analyticsContext), {}, {
        targetProduct: (_analyticsContext$tar = analyticsContext.targetProduct) !== null && _analyticsContext$tar !== void 0 ? _analyticsContext$tar : viewState.targetProduct
      })],
      payload: _objectSpread(_objectSpread({}, payload), {}, {
        actionSubjectId: 'closeDrawerButton'
      })
    });
    closeDrawer();
  }, [onAnalyticsEvent, closeDrawer, analyticsContext, viewState]);
  var handleOnCloseComplete = useCallback(function () {
    onClose(completionStatus);
  }, [onClose, completionStatus]);

  /**
   * Product Store Handlers
   */
  var handleProductStoreHandshake = useCallback(function () {
    onHandShake('productStoreSpa');
  }, [onHandShake]);
  var handleProductStoreOnChangeRoute = useCallback(function (route) {
    setViewState(function (prevState) {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        route: route
      });
    });
  }, []);
  var handleProductStoreOnTryClicked = useCallback(function (product, extensions) {
    setViewState(function (prevState) {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        spa: 'cross-flow-frontend',
        targetProduct: product,
        extensions: extensions
      });
    });
  }, []);

  /**
   * Cross-flow Frontend Handlers
   */
  var handleCrossFlowHandshake = useCallback(function () {
    onHandShake('crossFlowSpa');
  }, [onHandShake]);
  var handleCrossFlowOnClose = useCallback(function () {
    if (journey === 'get-started') {
      /**
       * User has completed Get Started journey.
       * Cross Flow Frontend does not provide status, but only invokes the callback
       * when activation was complete
       *
       * NOTE: flushSync required to ensure completion status is updated before
       * running the drawer status.
       */
      flushSync(function () {
        setCompletionStatus({
          success: true
        });
      });
    }
    closeDrawer();
  }, [closeDrawer, journey]);
  var contextState = useMemo(function () {
    return {
      state: viewState,
      setViewState: setViewState
    };
  }, [viewState, setViewState]);
  var extensionsWithOptionalProductStoreExtensions = useMemo(function () {
    return viewState.spa === 'cross-flow-frontend' && viewState.extensions ? combineExtensions(extensions !== null && extensions !== void 0 ? extensions : {}, viewState.extensions) : extensions;
  }, [viewState, extensions]);
  return /*#__PURE__*/React.createElement(Drawer, {
    width: "full",
    zIndex: zIndex,
    isOpen: isDrawerOpen,
    onClose: handleOnClose,
    onCloseComplete: handleOnCloseComplete,
    testId: "cross-flow-support-drawer"
  }, /*#__PURE__*/React.createElement(ViewStateContext.Provider, {
    value: contextState
  }, /*#__PURE__*/React.createElement(CompiledDrawerContainer, null, /*#__PURE__*/React.createElement(CrossFlowSupportHeader, null), /*#__PURE__*/React.createElement(DrawerContent, {
    xcss: styles.content
  }, (isFedRamp() || isIsolatedCloud()) && fg('ic_fedramp_screen_in_cross-flow_support') ? /*#__PURE__*/React.createElement(AnalyticsContext, {
    data: {
      source: 'cross-flow-support'
    }
  }, /*#__PURE__*/React.createElement(IcFedrampScreen, null)) : /*#__PURE__*/React.createElement(React.Fragment, null, viewState.spa === 'product-store' && /*#__PURE__*/React.createElement(ProductStoreComponent, {
    edgePrefix: edgePrefix,
    cloudId: cloudId,
    locale: locale,
    route: viewState.route,
    originProduct: originProduct,
    theme: theme,
    experimentalOptions: experimentalOptions,
    extensions: extensions,
    onClose: closeDrawer,
    onTryClicked: handleProductStoreOnTryClicked,
    onAnalyticsEvent: onAnalyticsEvent,
    onChangeRoute: handleProductStoreOnChangeRoute,
    plugins: plugins,
    onHandShake: handleProductStoreHandshake,
    isStandaloneProductPage: journey === 'decide',
    isLinkExpansion: redirectToWac,
    env: env,
    sourceContext: sourceContext,
    sourceComponent: sourceComponent,
    journey: journey
  }), viewState.spa === 'cross-flow-frontend' && /*#__PURE__*/React.createElement(CrossFlowComponent, {
    edgePrefix: edgePrefix,
    onClose: handleCrossFlowOnClose,
    cloudId: cloudId,
    locale: locale,
    sourceContext: sourceContext,
    sourceComponent: sourceComponent,
    targetProduct: viewState.targetProduct,
    originProduct: toCrossFlowOrigin(originProduct),
    theme: theme,
    experimentalOptions: experimentalOptions,
    extensions: extensionsWithOptionalProductStoreExtensions,
    onAnalyticsEvent: onAnalyticsEvent,
    onHandShake: handleCrossFlowHandshake,
    plugins: plugins,
    env: env,
    journey: journey
  }))))));
};